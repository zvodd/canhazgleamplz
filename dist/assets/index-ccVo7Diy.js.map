{"version":3,"file":"index-ccVo7Diy.js","sources":["../../build/dev/javascript/gleam_stdlib/gleam_stdlib.mjs","../../build/dev/javascript/gleam_stdlib/gleam/io.mjs","../../src/ok.ffi.mjs","../../src/canhazgleamplz.gleam","../../src/main.js"],"sourcesContent":["import {\n  BitArray,\n  Error,\n  List,\n  Ok,\n  Result,\n  UtfCodepoint,\n  stringBits,\n  toBitArray,\n  NonEmpty,\n  CustomType,\n} from \"./gleam.mjs\";\nimport {\n  CompileError as RegexCompileError,\n  Match as RegexMatch,\n} from \"./gleam/regex.mjs\";\nimport { DecodeError } from \"./gleam/dynamic.mjs\";\nimport { Some, None } from \"./gleam/option.mjs\";\nimport Dict from \"./dict.mjs\";\n\nconst Nil = undefined;\nconst NOT_FOUND = {};\n\nexport function identity(x) {\n  return x;\n}\n\nexport function parse_int(value) {\n  if (/^[-+]?(\\d+)$/.test(value)) {\n    return new Ok(parseInt(value));\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function parse_float(value) {\n  if (/^[-+]?(\\d+)\\.(\\d+)([eE][-+]?\\d+)?$/.test(value)) {\n    return new Ok(parseFloat(value));\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function to_string(term) {\n  return term.toString();\n}\n\nexport function float_to_string(float) {\n  const string = float.toString();\n  if (string.indexOf(\".\") >= 0) {\n    return string;\n  } else {\n    return string + \".0\";\n  }\n}\n\nexport function int_to_base_string(int, base) {\n  return int.toString(base).toUpperCase();\n}\n\nconst int_base_patterns = {\n  2: /[^0-1]/,\n  3: /[^0-2]/,\n  4: /[^0-3]/,\n  5: /[^0-4]/,\n  6: /[^0-5]/,\n  7: /[^0-6]/,\n  8: /[^0-7]/,\n  9: /[^0-8]/,\n  10: /[^0-9]/,\n  11: /[^0-9a]/,\n  12: /[^0-9a-b]/,\n  13: /[^0-9a-c]/,\n  14: /[^0-9a-d]/,\n  15: /[^0-9a-e]/,\n  16: /[^0-9a-f]/,\n  17: /[^0-9a-g]/,\n  18: /[^0-9a-h]/,\n  19: /[^0-9a-i]/,\n  20: /[^0-9a-j]/,\n  21: /[^0-9a-k]/,\n  22: /[^0-9a-l]/,\n  23: /[^0-9a-m]/,\n  24: /[^0-9a-n]/,\n  25: /[^0-9a-o]/,\n  26: /[^0-9a-p]/,\n  27: /[^0-9a-q]/,\n  28: /[^0-9a-r]/,\n  29: /[^0-9a-s]/,\n  30: /[^0-9a-t]/,\n  31: /[^0-9a-u]/,\n  32: /[^0-9a-v]/,\n  33: /[^0-9a-w]/,\n  34: /[^0-9a-x]/,\n  35: /[^0-9a-y]/,\n  36: /[^0-9a-z]/,\n};\n\nexport function int_from_base_string(string, base) {\n  if (int_base_patterns[base].test(string.replace(/^-/, \"\").toLowerCase())) {\n    return new Error(Nil);\n  }\n\n  const result = parseInt(string, base);\n\n  if (isNaN(result)) {\n    return new Error(Nil);\n  }\n\n  return new Ok(result);\n}\n\nexport function string_replace(string, target, substitute) {\n  if (typeof string.replaceAll !== \"undefined\") {\n    return string.replaceAll(target, substitute);\n  }\n  // Fallback for older Node.js versions:\n  // 1. <https://stackoverflow.com/a/1144788>\n  // 2. <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping>\n  // TODO: This fallback could be remove once Node.js 14 is EOL\n  // aka <https://nodejs.org/en/about/releases/> on or after 2024-04-30\n  return string.replace(\n    // $& means the whole matched string\n    new RegExp(target.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\"),\n    substitute,\n  );\n}\n\nexport function string_reverse(string) {\n  return [...string].reverse().join(\"\");\n}\n\nexport function string_length(string) {\n  if (string === \"\") {\n    return 0;\n  }\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    let i = 0;\n    for (const _ of iterator) {\n      i++;\n    }\n    return i;\n  } else {\n    return string.match(/./gsu).length;\n  }\n}\n\nexport function graphemes(string) {\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    return List.fromArray(Array.from(iterator).map((item) => item.segment));\n  } else {\n    return List.fromArray(string.match(/./gsu));\n  }\n}\n\nfunction graphemes_iterator(string) {\n  if (globalThis.Intl && Intl.Segmenter) {\n    return new Intl.Segmenter().segment(string)[Symbol.iterator]();\n  }\n}\n\nexport function pop_grapheme(string) {\n  let first;\n  const iterator = graphemes_iterator(string);\n  if (iterator) {\n    first = iterator.next().value?.segment;\n  } else {\n    first = string.match(/./su)?.[0];\n  }\n  if (first) {\n    return new Ok([first, string.slice(first.length)]);\n  } else {\n    return new Error(Nil);\n  }\n}\n\nexport function lowercase(string) {\n  return string.toLowerCase();\n}\n\nexport function uppercase(string) {\n  return string.toUpperCase();\n}\n\nexport function less_than(a, b) {\n  return a < b;\n}\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function split(xs, pattern) {\n  return List.fromArray(xs.split(pattern));\n}\n\nexport function join(xs, separator) {\n  const iterator = xs[Symbol.iterator]();\n  let result = iterator.next().value || \"\";\n  let current = iterator.next();\n  while (!current.done) {\n    result = result + separator + current.value;\n    current = iterator.next();\n  }\n  return result;\n}\n\nexport function concat(xs) {\n  let result = \"\";\n  for (const x of xs) {\n    result = result + x;\n  }\n  return result;\n}\n\nexport function length(data) {\n  return data.length;\n}\n\nexport function crop_string(string, substring) {\n  return string.substring(string.indexOf(substring));\n}\n\nexport function contains_string(haystack, needle) {\n  return haystack.indexOf(needle) >= 0;\n}\n\nexport function starts_with(haystack, needle) {\n  return haystack.startsWith(needle);\n}\n\nexport function ends_with(haystack, needle) {\n  return haystack.endsWith(needle);\n}\n\nexport function split_once(haystack, needle) {\n  const index = haystack.indexOf(needle);\n  if (index >= 0) {\n    const before = haystack.slice(0, index);\n    const after = haystack.slice(index + needle.length);\n    return new Ok([before, after]);\n  } else {\n    return new Error(Nil);\n  }\n}\n\nconst unicode_whitespaces = [\n  \"\\u0020\", // Space\n  \"\\u0009\", // Horizontal tab\n  \"\\u000A\", // Line feed\n  \"\\u000B\", // Vertical tab\n  \"\\u000C\", // Form feed\n  \"\\u000D\", // Carriage return\n  \"\\u0085\", // Next line\n  \"\\u2028\", // Line separator\n  \"\\u2029\", // Paragraph separator\n].join(\"\");\n\nconst left_trim_regex = new RegExp(`^([${unicode_whitespaces}]*)`, \"g\");\nconst right_trim_regex = new RegExp(`([${unicode_whitespaces}]*)$`, \"g\");\n\nexport function trim(string) {\n  return trim_left(trim_right(string));\n}\n\nexport function trim_left(string) {\n  return string.replace(left_trim_regex, \"\");\n}\n\nexport function trim_right(string) {\n  return string.replace(right_trim_regex, \"\");\n}\n\nexport function bit_array_from_string(string) {\n  return toBitArray([stringBits(string)]);\n}\n\nexport function bit_array_concat(bit_arrays) {\n  return toBitArray(bit_arrays.toArray().map((b) => b.buffer));\n}\n\nexport function console_log(term) {\n  console.log(term);\n}\n\nexport function console_error(term) {\n  console.error(term);\n}\n\nexport function crash(message) {\n  throw new globalThis.Error(message);\n}\n\nexport function bit_array_to_string(bit_array) {\n  try {\n    const decoder = new TextDecoder(\"utf-8\", { fatal: true });\n    return new Ok(decoder.decode(bit_array.buffer));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nexport function print(string) {\n  if (typeof process === \"object\") {\n    process.stdout.write(string); // We can write without a trailing newline\n  } else if (typeof Deno === \"object\") {\n    Deno.stdout.writeSync(new TextEncoder().encode(string)); // We can write without a trailing newline\n  } else {\n    console.log(string); // We're in a browser. Newlines are mandated\n  }\n}\n\nexport function print_error(string) {\n  if (typeof process === \"object\" && process.stderr?.write) {\n    process.stderr.write(string); // We can write without a trailing newline\n  } else if (typeof Deno === \"object\") {\n    Deno.stderr.writeSync(new TextEncoder().encode(string)); // We can write without a trailing newline\n  } else {\n    console.error(string); // We're in a browser. Newlines are mandated\n  }\n}\n\nexport function print_debug(string) {\n  if (typeof process === \"object\" && process.stderr?.write) {\n    process.stderr.write(string + \"\\n\"); // If we're in Node.js, use `stderr`\n  } else if (typeof Deno === \"object\") {\n    Deno.stderr.writeSync(new TextEncoder().encode(string + \"\\n\")); // If we're in Deno, use `stderr`\n  } else {\n    console.log(string); // Otherwise, use `console.log` (so that it doesn't look like an error)\n  }\n}\n\nexport function ceiling(float) {\n  return Math.ceil(float);\n}\n\nexport function floor(float) {\n  return Math.floor(float);\n}\n\nexport function round(float) {\n  return Math.round(float);\n}\n\nexport function truncate(float) {\n  return Math.trunc(float);\n}\n\nexport function power(base, exponent) {\n  // It is checked in Gleam that:\n  // - The base is non-negative and that the exponent is not fractional.\n  // - The base is non-zero and the exponent is non-negative (otherwise\n  //   the result will essentially be division by zero).\n  // It can thus be assumed that valid input is passed to the Math.pow\n  // function and a NaN or Infinity value will not be produced.\n  return Math.pow(base, exponent);\n}\n\nexport function random_uniform() {\n  const random_uniform_result = Math.random();\n  // With round-to-nearest-even behavior, the ranges claimed for the functions below\n  // (excluding the one for Math.random() itself) aren't exact.\n  // If extremely large bounds are chosen (2^53 or higher),\n  // it's possible in extremely rare cases to calculate the usually-excluded upper bound.\n  // Note that as numbers in JavaScript are IEEE 754 floating point numbers\n  // See: <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random>\n  // Because of this, we just loop 'until' we get a valid result where 0.0 <= x < 1.0:\n  if (random_uniform_result === 1.0) {\n    return random_uniform();\n  }\n  return random_uniform_result;\n}\n\nexport function bit_array_slice(bits, position, length) {\n  const start = Math.min(position, position + length);\n  const end = Math.max(position, position + length);\n  if (start < 0 || end > bits.length) return new Error(Nil);\n  const byteOffset = bits.buffer.byteOffset + start;\n  const buffer = new Uint8Array(\n    bits.buffer.buffer,\n    byteOffset,\n    Math.abs(length),\n  );\n  return new Ok(new BitArray(buffer));\n}\n\nexport function codepoint(int) {\n  return new UtfCodepoint(int);\n}\n\nexport function string_to_codepoint_integer_list(string) {\n  return List.fromArray(Array.from(string).map((item) => item.codePointAt(0)));\n}\n\nexport function utf_codepoint_list_to_string(utf_codepoint_integer_list) {\n  return utf_codepoint_integer_list\n    .toArray()\n    .map((x) => String.fromCodePoint(x.value))\n    .join(\"\");\n}\n\nexport function utf_codepoint_to_int(utf_codepoint) {\n  return utf_codepoint.value;\n}\n\nexport function regex_check(regex, string) {\n  regex.lastIndex = 0;\n  return regex.test(string);\n}\n\nexport function compile_regex(pattern, options) {\n  try {\n    let flags = \"gu\";\n    if (options.case_insensitive) flags += \"i\";\n    if (options.multi_line) flags += \"m\";\n    return new Ok(new RegExp(pattern, flags));\n  } catch (error) {\n    const number = (error.columnNumber || 0) | 0;\n    return new Error(new RegexCompileError(error.message, number));\n  }\n}\n\nexport function regex_split(regex, string) {\n  return List.fromArray(\n    string.split(regex).map((item) => (item === undefined ? \"\" : item)),\n  ); \n}\n\nexport function regex_scan(regex, string) {\n  const matches = Array.from(string.matchAll(regex)).map((match) => {\n    const content = match[0];\n    const submatches = [];\n    for (let n = match.length - 1; n > 0; n--) {\n      if (match[n]) {\n        submatches[n - 1] = new Some(match[n]);\n        continue;\n      }\n      if (submatches.length > 0) {\n        submatches[n - 1] = new None();\n      }\n    }\n    return new RegexMatch(content, List.fromArray(submatches));\n  });\n  return List.fromArray(matches);\n}\n\nexport function regex_replace(regex, original_string, replacement) {\n  return original_string.replaceAll(regex, replacement)\n}\n\nexport function new_map() {\n  return Dict.new();\n}\n\nexport function map_size(map) {\n  return map.size;\n}\n\nexport function map_to_list(map) {\n  return List.fromArray(map.entries());\n}\n\nexport function map_remove(key, map) {\n  return map.delete(key);\n}\n\nexport function map_get(map, key) {\n  const value = map.get(key, NOT_FOUND);\n  if (value === NOT_FOUND) {\n    return new Error(Nil);\n  }\n  return new Ok(value);\n}\n\nexport function map_insert(key, value, map) {\n  return map.set(key, value);\n}\n\nfunction unsafe_percent_decode(string) {\n  return decodeURIComponent(string || \"\");\n}\n\nfunction unsafe_percent_decode_query(string) {\n  return decodeURIComponent((string || \"\").replace(\"+\", \" \"));\n}\n\nexport function percent_decode(string) {\n  try {\n    return new Ok(unsafe_percent_decode(string));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nexport function percent_encode(string) {\n  return encodeURIComponent(string).replace(\"%2B\", \"+\");\n}\n\nexport function parse_query(query) {\n  try {\n    const pairs = [];\n    for (const section of query.split(\"&\")) {\n      const [key, value] = section.split(\"=\");\n      if (!key) continue;\n\n      const decodedKey = unsafe_percent_decode_query(key)\n      const decodedValue = unsafe_percent_decode_query(value)\n      pairs.push([decodedKey, decodedValue])\n    }\n    return new Ok(List.fromArray(pairs));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nconst b64EncodeLookup = [\n  65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83,\n  84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106,\n  107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n  122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47,\n];\n\nlet b64TextDecoder;\n\n// Implementation based on https://github.com/mitschabaude/fast-base64/blob/main/js.js\nexport function encode64(bit_array, padding) {\n  b64TextDecoder ??= new TextDecoder();\n\n  const bytes = bit_array.buffer;\n\n  const m = bytes.length;\n  const k = m % 3;\n  const n = Math.floor(m / 3) * 4 + (k && k + 1);\n  const N = Math.ceil(m / 3) * 4;\n  const encoded = new Uint8Array(N);\n\n  for (let i = 0, j = 0; j < m; i += 4, j += 3) {\n    const y = (bytes[j] << 16) + (bytes[j + 1] << 8) + (bytes[j + 2] | 0);\n    encoded[i] = b64EncodeLookup[y >> 18];\n    encoded[i + 1] = b64EncodeLookup[(y >> 12) & 0x3f];\n    encoded[i + 2] = b64EncodeLookup[(y >> 6) & 0x3f];\n    encoded[i + 3] = b64EncodeLookup[y & 0x3f];\n  }\n\n  let base64 = b64TextDecoder.decode(new Uint8Array(encoded.buffer, 0, n));\n\n  if (padding) {\n    if (k === 1) {\n      base64 += \"==\";\n    }\n    else if (k === 2) {\n      base64 += \"=\";\n    }\n  }\n\n  return base64;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Glossary/Base64\nexport function decode64(sBase64) {\n  try {\n    const binString = atob(sBase64);\n    const length = binString.length;\n    const array = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        array[i] = binString.charCodeAt(i);\n    }\n    return new Ok(new BitArray(array));\n  } catch {\n    return new Error(Nil);\n  }\n}\n\nexport function classify_dynamic(data) {\n  if (typeof data === \"string\") {\n    return \"String\";\n  } else if (typeof data === \"boolean\") {\n    return \"Bool\";\n  } else if (data instanceof Result) {\n    return \"Result\";\n  } else if (data instanceof List) {\n    return \"List\";\n  } else if (data instanceof BitArray) {\n    return \"BitArray\";\n  } else if (data instanceof Dict) {\n    return \"Dict\";\n  } else if (Number.isInteger(data)) {\n    return \"Int\";\n  } else if (Array.isArray(data)) {\n    return `Tuple of ${data.length} elements`;\n  } else if (typeof data === \"number\") {\n    return \"Float\";\n  } else if (data === null) {\n    return \"Null\";\n  } else if (data === undefined) {\n    return \"Nil\";\n  } else {\n    const type = typeof data;\n    return type.charAt(0).toUpperCase() + type.slice(1);\n  }\n}\n\nfunction decoder_error(expected, got) {\n  return decoder_error_no_classify(expected, classify_dynamic(got));\n}\n\nfunction decoder_error_no_classify(expected, got) {\n  return new Error(\n    List.fromArray([new DecodeError(expected, got, List.fromArray([]))]),\n  );\n}\n\nexport function decode_string(data) {\n  return typeof data === \"string\"\n    ? new Ok(data)\n    : decoder_error(\"String\", data);\n}\n\nexport function decode_int(data) {\n  return Number.isInteger(data) ? new Ok(data) : decoder_error(\"Int\", data);\n}\n\nexport function decode_float(data) {\n  return typeof data === \"number\" ? new Ok(data) : decoder_error(\"Float\", data);\n}\n\nexport function decode_bool(data) {\n  return typeof data === \"boolean\" ? new Ok(data) : decoder_error(\"Bool\", data);\n}\n\nexport function decode_bit_array(data) {\n  if (data instanceof BitArray) {\n    return new Ok(data);\n  }\n  if (data instanceof Uint8Array) {\n    return new Ok(new BitArray(data));\n  }\n  return decoder_error(\"BitArray\", data);\n}\n\nexport function decode_tuple(data) {\n  return Array.isArray(data) ? new Ok(data) : decoder_error(\"Tuple\", data);\n}\n\nexport function decode_tuple2(data) {\n  return decode_tupleN(data, 2);\n}\n\nexport function decode_tuple3(data) {\n  return decode_tupleN(data, 3);\n}\n\nexport function decode_tuple4(data) {\n  return decode_tupleN(data, 4);\n}\n\nexport function decode_tuple5(data) {\n  return decode_tupleN(data, 5);\n}\n\nexport function decode_tuple6(data) {\n  return decode_tupleN(data, 6);\n}\n\nfunction decode_tupleN(data, n) {\n  if (Array.isArray(data) && data.length == n) {\n    return new Ok(data);\n  }\n\n  const list = decode_exact_length_list(data, n);\n  if (list) return new Ok(list);\n\n  return decoder_error(`Tuple of ${n} elements`, data);\n}\n\nfunction decode_exact_length_list(data, n) {\n  if (!(data instanceof List)) return;\n\n  const elements = [];\n  let current = data;\n\n  for (let i = 0; i < n; i++) {\n    if (!(current instanceof NonEmpty)) break;\n    elements.push(current.head);\n    current = current.tail;\n  }\n\n  if (elements.length === n && !(current instanceof NonEmpty)) return elements;\n}\n\nexport function tuple_get(data, index) {\n  return index >= 0 && data.length > index\n    ? new Ok(data[index])\n    : new Error(Nil);\n}\n\nexport function decode_list(data) {\n  if (Array.isArray(data)) {\n    return new Ok(List.fromArray(data));\n  }\n  return data instanceof List ? new Ok(data) : decoder_error(\"List\", data);\n}\n\nexport function decode_result(data) {\n  return data instanceof Result ? new Ok(data) : decoder_error(\"Result\", data);\n}\n\nexport function decode_map(data) {\n  if (data instanceof Dict) {\n    return new Ok(data);\n  }\n  if (data instanceof Map || data instanceof WeakMap) {\n    return new Ok(Dict.fromMap(data));\n  }\n  if (data == null) {\n    return decoder_error(\"Dict\", data);\n  }\n  if (typeof data !== \"object\") {\n    return decoder_error(\"Dict\", data);\n  }\n  const proto = Object.getPrototypeOf(data);\n  if (proto === Object.prototype || proto === null) {\n    return new Ok(Dict.fromObject(data));\n  }\n  return decoder_error(\"Dict\", data);\n}\n\nexport function decode_option(data, decoder) {\n  if (data === null || data === undefined || data instanceof None)\n    return new Ok(new None());\n  if (data instanceof Some) data = data[0];\n  const result = decoder(data);\n  if (result.isOk()) {\n    return new Ok(new Some(result[0]));\n  } else {\n    return result;\n  }\n}\n\nexport function decode_field(value, name) {\n  const not_a_map_error = () => decoder_error(\"Dict\", value);\n\n  if (\n    value instanceof Dict ||\n    value instanceof WeakMap ||\n    value instanceof Map\n  ) {\n    const entry = map_get(value, name);\n    return new Ok(entry.isOk() ? new Some(entry[0]) : new None());\n  } else if (value === null) {\n    return not_a_map_error();\n  } else if (Object.getPrototypeOf(value) == Object.prototype) {\n    return try_get_field(value, name, () => new Ok(new None()));\n  } else {\n    return try_get_field(value, name, not_a_map_error);\n  }\n}\n\nfunction try_get_field(value, field, or_else) {\n  try {\n    return field in value ? new Ok(new Some(value[field])) : or_else();\n  } catch {\n    return or_else();\n  }\n}\n\nexport function byte_size(string) {\n  return new TextEncoder().encode(string).length;\n}\n\n// In Javascript bitwise operations convert numbers to a sequence of 32 bits\n// while Erlang uses arbitrary precision.\n// To get around this problem and get consistent results use BigInt and then\n// downcast the value back to a Number value.\n\nexport function bitwise_and(x, y) {\n  return Number(BigInt(x) & BigInt(y));\n}\n\nexport function bitwise_not(x) {\n  return Number(~BigInt(x));\n}\n\nexport function bitwise_or(x, y) {\n  return Number(BigInt(x) | BigInt(y));\n}\n\nexport function bitwise_exclusive_or(x, y) {\n  return Number(BigInt(x) ^ BigInt(y));\n}\n\nexport function bitwise_shift_left(x, y) {\n  return Number(BigInt(x) << BigInt(y));\n}\n\nexport function bitwise_shift_right(x, y) {\n  return Number(BigInt(x) >> BigInt(y));\n}\n\nexport function inspect(v) {\n  const t = typeof v;\n  if (v === true) return \"True\";\n  if (v === false) return \"False\";\n  if (v === null) return \"//js(null)\";\n  if (v === undefined) return \"Nil\";\n  if (t === \"string\") return inspectString(v);\n  if (t === \"bigint\" || t === \"number\") return v.toString();\n  if (Array.isArray(v)) return `#(${v.map(inspect).join(\", \")})`;\n  if (v instanceof List) return inspectList(v);\n  if (v instanceof UtfCodepoint) return inspectUtfCodepoint(v);\n  if (v instanceof BitArray) return inspectBitArray(v);\n  if (v instanceof CustomType) return inspectCustomType(v);\n  if (v instanceof Dict) return inspectDict(v);\n  if (v instanceof Set) return `//js(Set(${[...v].map(inspect).join(\", \")}))`;\n  if (v instanceof RegExp) return `//js(${v})`;\n  if (v instanceof Date) return `//js(Date(\"${v.toISOString()}\"))`;\n  if (v instanceof Function) {\n    const args = [];\n    for (const i of Array(v.length).keys())\n      args.push(String.fromCharCode(i + 97));\n    return `//fn(${args.join(\", \")}) { ... }`;\n  }\n  return inspectObject(v);\n}\n\nfunction inspectString(str) {\n  let new_str = \"\\\"\";\n  for (let i = 0; i < str.length; i++) {\n    let char = str[i];\n    switch (char) {\n      case '\\n': new_str += \"\\\\n\"; break;\n      case '\\r': new_str += \"\\\\r\"; break;\n      case '\\t': new_str += \"\\\\t\"; break;\n      case '\\f': new_str += \"\\\\f\"; break;\n      case '\\\\': new_str += \"\\\\\\\\\"; break;\n      case '\\\"': new_str += \"\\\\\\\"\"; break;\n      default:\n        if (char < ' ' || (char > '~' && char < '\\u{00A0}')) {\n          new_str += \"\\\\u{\" + char.charCodeAt(0).toString(16).toUpperCase().padStart(4, \"0\") + \"}\";\n        } else {\n          new_str += char;\n        }\n    }\n  }\n  new_str += \"\\\"\";\n  return new_str;\n}\n\nfunction inspectDict(map) {\n  let body = \"dict.from_list([\";\n  let first = true;\n  map.forEach((value, key) => {\n    if (!first) body = body + \", \";\n    body = body + \"#(\" + inspect(key) + \", \" + inspect(value) + \")\";\n    first = false;\n  });\n  return body + \"])\";\n}\n\nfunction inspectObject(v) {\n  const name = Object.getPrototypeOf(v)?.constructor?.name || \"Object\";\n  const props = [];\n  for (const k of Object.keys(v)) {\n    props.push(`${inspect(k)}: ${inspect(v[k])}`);\n  }\n  const body = props.length ? \" \" + props.join(\", \") + \" \" : \"\";\n  const head = name === \"Object\" ? \"\" : name + \" \";\n  return `//js(${head}{${body}})`;\n}\n\nfunction inspectCustomType(record) {\n  const props = Object.keys(record)\n    .map((label) => {\n      const value = inspect(record[label]);\n      return isNaN(parseInt(label)) ? `${label}: ${value}` : value;\n    })\n    .join(\", \");\n  return props\n    ? `${record.constructor.name}(${props})`\n    : record.constructor.name;\n}\n\nexport function inspectList(list) {\n  return `[${list.toArray().map(inspect).join(\", \")}]`;\n}\n\nexport function inspectBitArray(bits) {\n  return `<<${Array.from(bits.buffer).join(\", \")}>>`;\n}\n\nexport function inspectUtfCodepoint(codepoint) {\n  return `//utfcodepoint(${String.fromCodePoint(codepoint.value)})`;\n}\n\nexport function base16_encode(bit_array) {\n  let result = \"\";\n  for (const byte of bit_array.buffer) {\n    result += byte.toString(16).padStart(2, \"0\").toUpperCase();\n  }\n  return result;\n}\n\nexport function base16_decode(string) {\n  const bytes = new Uint8Array(string.length / 2);\n  for (let i = 0; i < string.length; i += 2) {\n    const a = parseInt(string[i], 16);\n    const b = parseInt(string[i + 1], 16);\n    if (isNaN(a) || isNaN(b)) return new Error(Nil);\n    bytes[i / 2] = a * 16 + b;\n  }\n  return new Ok(new BitArray(bytes));\n}\n\nexport function bit_array_inspect(bits) {\n  return `<<${[...bits.buffer].join(\", \")}>>`;\n}\n","import * as $string from \"../gleam/string.mjs\";\nimport {\n  print as do_print,\n  print_error as do_print_error,\n  console_log as do_println,\n  console_error as do_println_error,\n  print_debug as do_debug_println,\n} from \"../gleam_stdlib.mjs\";\n\nexport function print(string) {\n  return do_print(string);\n}\n\nexport function print_error(string) {\n  return do_print_error(string);\n}\n\nexport function println(string) {\n  return do_println(string);\n}\n\nexport function println_error(string) {\n  return do_println_error(string);\n}\n\nexport function debug(term) {\n  let _pipe = term;\n  let _pipe$1 = $string.inspect(_pipe);\n  do_debug_println(_pipe$1)\n  return term;\n}\n","import { Ok, Error } from \"./gleam.mjs\";\n\n\nexport function print(message){\n    console.log(message)\n    const doc = globalThis.window.document\n    const pre_el = doc.createElement(\"pre\")\n    pre_el.innerText = message\n    doc.body.appendChild(pre_el)\n}\n","import gleam/io\n\n@external(javascript, \"./ok.ffi.mjs\", \"print\")\npub fn print(str: String) -> Nil\n\npub fn main(){\n  io.println(\"Hello from io!\")\n  print(\"Hello from Gleam JS FFI!\")\n}\n","import { main } from \"./canhazgleamplz.gleam\";\nmain();"],"names":["console_log","term","println","string","do_println","print","message","doc","pre_el","main","$io.println"],"mappings":"ssBA2RO,SAASA,EAAYC,EAAM,CAChC,QAAQ,IAAIA,CAAI,CAClB,CC5QO,SAASC,EAAQC,EAAQ,CAC9B,OAAOC,EAAWD,CAAM,CAC1B,CChBO,SAASE,EAAMC,EAAQ,CAC1B,QAAQ,IAAIA,CAAO,EACnB,MAAMC,EAAM,WAAW,OAAO,SACxBC,EAASD,EAAI,cAAc,KAAK,EACtCC,EAAO,UAAYF,EACnBC,EAAI,KAAK,YAAYC,CAAM,CAC/B,CCTA,SAAAC,GAAA,CAAAC,OAAAA,EAAA,gBAAA,EAAAL,EAAA,0BAAA,CAAA,CCCAI,EAAM"}